theory StatVerifSecurityDevice begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, fst/1, pair/2, pk/1, snd/1
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2



heuristic: p









lemma source [sources]:
  all-traces
  "∀ m #i.
    (Access( m ) @ #i) ⇒
    (((∃ #j. (!KU( m ) @ #j) ∧ (#j < #i)) ∨
      (∃ x #j. Exclusive( x, m ) @ #j)) ∨
     (∃ y #j. Exclusive( m, y ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m #i.
  (Access( m ) @ #i)
 ∧
  (∀ #j. (!KU( m ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ x #j. (Exclusive( x, m ) @ #j) ⇒ ⊥) ∧
  (∀ y #j. (Exclusive( m, y ) @ #j) ⇒ ⊥)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  solve( (∀ m #i.
           (Access( m ) @ #i)
          ⇒
           ((last(#i)) ∨
            (∃ #j. (!KU( m ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)) ∨
            (∃ x #j. (Exclusive( x, m ) @ #j) ∧ ¬(last(#j))) ∨
            (∃ y #j. (Exclusive( m, y ) @ #j) ∧ ¬(last(#j)))))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t1 yp.
                (Insert( x, yp ) @ #t1)
               ∧
                (¬(last(#t1))) ∧
                (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                (¬(#t1 = #t2)) ∧
                (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_0( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_1( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3))) )
    case case_1
    solve( (last(#i))  ∥
           (∃ #j. (!KU( m ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))  ∥
           (∃ x #j. (Exclusive( x, m ) @ #j) ∧ ¬(last(#j)))  ∥
           (∃ y #j. (Exclusive( m, y ) @ #j) ∧ ¬(last(#j))) )
      case case_1
      solve( Access( m ) @ #i )
        case eventAccessx_0_11111121211111
        solve( State_11111121211111( lock, s, sk, m, y, status ) ▶₀ #i )
          case ifstatusleft_0_1111112121111
          solve( (#vr.12 < #t2)  ∥ (#vr.12 = #t2) )
            case case_1
            solve( Insert( <'F_status', ~n.1>, 'left' ) @ #t2 )
              case insertFstatussreq_0_111111211111111
              solve( State_111111211111111( lock, 'left', ~n.1, sk, status ) ▶₀ #t2 )
                case eventInitDevices_0_11111121111111
                solve( ((#vr.3 < #vr.23) ∧
                        (∃ #t2.
                          (Unlock_1( '1', ~n, ~n.1 ) @ #t2)
                         ∧
                          (#vr.3 < #t2) ∧
                          (#t2 < #vr.23) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n, ~n.1 ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, ~n.1 ) @ #t0)
                           ⇒
                            ((#t0 < #vr.3) ∨ (#t0 = #vr.3) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, ~n.1 ) @ #t0)
                           ⇒
                            ((#t0 < #vr.3) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.23 < #vr.3) )
                  case case_1
                  solve( (#vr.12 < #t2.1)  ∥ (#vr.12 = #t2.1) )
                    case case_1
                    solve( Insert( <'F_status', ~n.1>, 'init' ) @ #t2.1 )
                      case insertFstatussinit_0_111
                      solve( State_111( ~n.1, sk ) ▶₀ #t2.1 )
                        case news_0_11
                        by contradiction /* cyclic */
                      qed
                    next
                      case insertFstatussreq_0_111111211111111
                      by solve( State_111111211111111( lock, 'init', ~n.1, sk, status
                                ) ▶₀ #t2.1 )
                    next
                      case insertFstatussreq_0_1111112111111211
                      by solve( State_1111112111111211( lock, 'init', ~n.1, sk, status
                                ) ▶₀ #t2.1 )
                    qed
                  next
                    case case_2
                    solve( Insert( <'F_status', ~n.1>, 'init' ) @ #t2.1 )
                      case insertFstatussinit_0_111
                      solve( Unlock_1( '1', ~n, ~n.1 ) @ #t2.2 )
                        case unlocks_0_1111112121111111
                        by contradiction /* cyclic */
                      next
                        case unlocks_0_11111121211112111
                        by contradiction /* cyclic */
                      next
                        case unlocks_0_111111212111122
                        by contradiction /* cyclic */
                      qed
                    qed
                  qed
                next
                  case case_2
                  solve( (#vr.12 < #t2.1)  ∥ (#vr.12 = #t2.1) )
                    case case_1
                    solve( Insert( <'F_status', ~n.1>, 'init' ) @ #t2.1 )
                      case insertFstatussinit_0_111
                      solve( State_111( ~n.1, sk ) ▶₀ #t2.1 )
                        case news_0_11
                        by contradiction /* cyclic */
                      qed
                    next
                      case insertFstatussreq_0_111111211111111
                      by solve( State_111111211111111( lock, 'init', ~n.1, sk, status
                                ) ▶₀ #t2.1 )
                    next
                      case insertFstatussreq_0_1111112111111211
                      by solve( State_1111112111111211( lock, 'init', ~n.1, sk, status
                                ) ▶₀ #t2.1 )
                    qed
                  next
                    case case_2
                    solve( Insert( <'F_status', ~n.1>, 'init' ) @ #t2.1 )
                      case insertFstatussinit_0_111
                      solve( Unlock_0( '0', ~n.3, ~n.1 ) @ #t2.2 )
                        case unlocks_0_1111112111111111
                        solve( State_1111112111111111( ~n.3, req, ~n.1, sk, status ) ▶₀ #t2.2 )
                          case insertFstatussreq_0_111111211111111
                          solve( (#t2.1 < #t2.3)  ∥ (#t2.1 = #t2.3) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            solve( !KU( aenc(<m, y>, pk(~n.2)) ) @ #vk )
                              case c_aenc
                              by contradiction /* from formulas */
                            next
                              case outaenclmrmpksk_0_1111211111
                              by contradiction /* from formulas */
                            next
                              case outx_0_111111212111111
                              solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.26))  ∥
                                     (∃ x #j. (Exclusive( x, t ) @ #j) ∧ ¬(last(#j)))  ∥
                                     (∃ y #j. (Exclusive( t, y ) @ #j) ∧ ¬(last(#j))) )
                                case case_1
                                by contradiction /* cyclic */
                              next
                                case case_2
                                solve( (#vr.39 < #t2.3)  ∥ (#vr.39 = #t2.3) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.6>, 'left' ) @ #t2.3 )
                                    case insertFstatussreq_0_111111211111111
                                    solve( State_111121111( x, t, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    solve( State_111121111( x, t, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  qed
                                next
                                  case case_2
                                  by solve( Insert( <'F_status', ~n.4>, 'left' ) @ #t2.3 )
                                qed
                              next
                                case case_3
                                solve( (#vr.39 < #t2.3)  ∥ (#vr.39 = #t2.3) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.6>, 'left' ) @ #t2.3 )
                                    case insertFstatussreq_0_111111211111111
                                    solve( State_111121111( t, y.1, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    solve( State_111121111( t, y.1, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  qed
                                next
                                  case case_2
                                  by solve( Insert( <'F_status', ~n.4>, 'left' ) @ #t2.3 )
                                qed
                              qed
                            next
                              case outy_0_1111112121111211
                              solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.26))  ∥
                                     (∃ x #j. (Exclusive( x, t ) @ #j) ∧ ¬(last(#j)))  ∥
                                     (∃ y #j. (Exclusive( t, y ) @ #j) ∧ ¬(last(#j))) )
                                case case_1
                                by contradiction /* cyclic */
                              next
                                case case_2
                                solve( (#vr.40 < #t2.3)  ∥ (#vr.40 = #t2.3) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.6>, 'right' ) @ #t2.3 )
                                    case insertFstatussreq_0_111111211111111
                                    solve( State_111121111( x, t, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    solve( State_111121111( x, t, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  qed
                                next
                                  case case_2
                                  by solve( Insert( <'F_status', ~n.4>, 'right' ) @ #t2.3 )
                                qed
                              next
                                case case_3
                                solve( (#vr.40 < #t2.3)  ∥ (#vr.40 = #t2.3) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.6>, 'right' ) @ #t2.3 )
                                    case insertFstatussreq_0_111111211111111
                                    solve( State_111121111( t, y.1, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    solve( State_111121111( t, y.1, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  qed
                                next
                                  case case_2
                                  by solve( Insert( <'F_status', ~n.4>, 'right' ) @ #t2.3 )
                                qed
                              qed
                            qed
                          qed
                        qed
                      next
                        case unlocks_0_11111121111112111
                        by solve( State_11111121111112111( ~n.3, req, ~n.1, sk, status
                                  ) ▶₀ #t2.2 )
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertFstatussreq_0_1111112111111211
              by solve( State_1111112111111211( lock, 'left', ~n.1, sk, status
                        ) ▶₀ #t2 )
            qed
          next
            case case_2
            by solve( Insert( <'F_status', ~n.1>, 'left' ) @ #t2 )
          qed
        qed
      next
        case eventAccessy_0_111111212111121
        solve( State_111111212111121( lock, s, sk, x, m, status ) ▶₀ #i )
          case ifstatusright_0_11111121211112
          solve( (#vr.13 < #t2)  ∥ (#vr.13 = #t2) )
            case case_1
            solve( Insert( <'F_status', ~n.1>, 'right' ) @ #t2 )
              case insertFstatussreq_0_111111211111111
              by solve( State_111111211111111( lock, 'right', ~n.1, sk, status
                        ) ▶₀ #t2 )
            next
              case insertFstatussreq_0_1111112111111211
              solve( State_1111112111111211( lock, 'right', ~n.1, sk, status ) ▶₀ #t2 )
                case eventInitDevices_0_111111211111121
                solve( ((#vr.4 < #vr.25) ∧
                        (∃ #t2.
                          (Unlock_1( '1', ~n, ~n.1 ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.25) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n, ~n.1 ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, ~n.1 ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, ~n.1 ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.25 < #vr.4) )
                  case case_1
                  solve( (#vr.13 < #t2.1)  ∥ (#vr.13 = #t2.1) )
                    case case_1
                    solve( Insert( <'F_status', ~n.1>, 'init' ) @ #t2.1 )
                      case insertFstatussinit_0_111
                      solve( State_111( ~n.1, sk ) ▶₀ #t2.1 )
                        case news_0_11
                        by contradiction /* cyclic */
                      qed
                    next
                      case insertFstatussreq_0_111111211111111
                      by solve( State_111111211111111( lock, 'init', ~n.1, sk, status
                                ) ▶₀ #t2.1 )
                    next
                      case insertFstatussreq_0_1111112111111211
                      by solve( State_1111112111111211( lock, 'init', ~n.1, sk, status
                                ) ▶₀ #t2.1 )
                    qed
                  next
                    case case_2
                    solve( Insert( <'F_status', ~n.1>, 'init' ) @ #t2.1 )
                      case insertFstatussinit_0_111
                      solve( Unlock_1( '1', ~n, ~n.1 ) @ #t2.2 )
                        case unlocks_0_1111112121111111
                        by contradiction /* cyclic */
                      next
                        case unlocks_0_11111121211112111
                        by contradiction /* cyclic */
                      next
                        case unlocks_0_111111212111122
                        by contradiction /* cyclic */
                      qed
                    qed
                  qed
                next
                  case case_2
                  solve( (#vr.13 < #t2.1)  ∥ (#vr.13 = #t2.1) )
                    case case_1
                    solve( Insert( <'F_status', ~n.1>, 'init' ) @ #t2.1 )
                      case insertFstatussinit_0_111
                      solve( State_111( ~n.1, sk ) ▶₀ #t2.1 )
                        case news_0_11
                        by contradiction /* cyclic */
                      qed
                    next
                      case insertFstatussreq_0_111111211111111
                      by solve( State_111111211111111( lock, 'init', ~n.1, sk, status
                                ) ▶₀ #t2.1 )
                    next
                      case insertFstatussreq_0_1111112111111211
                      by solve( State_1111112111111211( lock, 'init', ~n.1, sk, status
                                ) ▶₀ #t2.1 )
                    qed
                  next
                    case case_2
                    solve( Insert( <'F_status', ~n.1>, 'init' ) @ #t2.1 )
                      case insertFstatussinit_0_111
                      solve( Unlock_0( '0', ~n.3, ~n.1 ) @ #t2.2 )
                        case unlocks_0_1111112111111111
                        by solve( State_1111112111111111( ~n.3, req, ~n.1, sk, status
                                  ) ▶₀ #t2.2 )
                      next
                        case unlocks_0_11111121111112111
                        solve( State_11111121111112111( ~n.3, req, ~n.1, sk, status ) ▶₀ #t2.2 )
                          case insertFstatussreq_0_1111112111111211
                          solve( (#t2.1 < #t2.3)  ∥ (#t2.1 = #t2.3) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            solve( !KU( aenc(<x, m>, pk(~n.2)) ) @ #vk )
                              case c_aenc
                              by contradiction /* from formulas */
                            next
                              case outaenclmrmpksk_0_1111211111
                              by contradiction /* from formulas */
                            next
                              case outx_0_111111212111111
                              solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.28))  ∥
                                     (∃ x #j. (Exclusive( x, t ) @ #j) ∧ ¬(last(#j)))  ∥
                                     (∃ y #j. (Exclusive( t, y ) @ #j) ∧ ¬(last(#j))) )
                                case case_1
                                by contradiction /* cyclic */
                              next
                                case case_2
                                solve( (#vr.41 < #t2.3)  ∥ (#vr.41 = #t2.3) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.6>, 'left' ) @ #t2.3 )
                                    case insertFstatussreq_0_111111211111111
                                    solve( State_111121111( x.1, t, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    solve( State_111121111( x.1, t, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  qed
                                next
                                  case case_2
                                  by solve( Insert( <'F_status', ~n.4>, 'left' ) @ #t2.3 )
                                qed
                              next
                                case case_3
                                solve( (#vr.41 < #t2.3)  ∥ (#vr.41 = #t2.3) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.6>, 'left' ) @ #t2.3 )
                                    case insertFstatussreq_0_111111211111111
                                    solve( State_111121111( t, y, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    solve( State_111121111( t, y, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  qed
                                next
                                  case case_2
                                  by solve( Insert( <'F_status', ~n.4>, 'left' ) @ #t2.3 )
                                qed
                              qed
                            next
                              case outy_0_1111112121111211
                              solve( (∃ #j. (!KU( t ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.28))  ∥
                                     (∃ x #j. (Exclusive( x, t ) @ #j) ∧ ¬(last(#j)))  ∥
                                     (∃ y #j. (Exclusive( t, y ) @ #j) ∧ ¬(last(#j))) )
                                case case_1
                                by contradiction /* cyclic */
                              next
                                case case_2
                                solve( (#vr.42 < #t2.3)  ∥ (#vr.42 = #t2.3) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.6>, 'right' ) @ #t2.3 )
                                    case insertFstatussreq_0_111111211111111
                                    solve( State_111121111( x.1, t, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    solve( State_111121111( x.1, t, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  qed
                                next
                                  case case_2
                                  by solve( Insert( <'F_status', ~n.4>, 'right' ) @ #t2.3 )
                                qed
                              next
                                case case_3
                                solve( (#vr.42 < #t2.3)  ∥ (#vr.42 = #t2.3) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.6>, 'right' ) @ #t2.3 )
                                    case insertFstatussreq_0_111111211111111
                                    solve( State_111121111( t, y, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    solve( State_111121111( t, y, s, sk ) ▶₀ #j )
                                      case newrm_0_11112111
                                      by contradiction /* impossible chain */
                                    qed
                                  qed
                                next
                                  case case_2
                                  by solve( Insert( <'F_status', ~n.4>, 'right' ) @ #t2.3 )
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          next
            case case_2
            by solve( Insert( <'F_status', ~n.1>, 'right' ) @ #t2 )
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      by contradiction /* from formulas */
    next
      case case_4
      by contradiction /* from formulas */
    qed
  next
    case case_2
    solve( (#t1 = #t2)  ∥ (#t2 < #t1) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_3
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_0( '0', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_4
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_1( '1', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma reachability_left:
  exists-trace "∃ x y #i #j. (Exclusive( x, y ) @ #i) ∧ (K( x ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ x y #i #j. (Exclusive( x, y ) @ #i) ∧ (K( x ) @ #j)"
*/
simplify
solve( State_111121111( x, y, s, sk ) ▶₀ #i )
  case newrm_0_11112111
  solve( !KU( ~n ) @ #vk )
    case outx_0_111111212111111
    solve( (#vr.26 < #t2)  ∥ (#vr.26 = #t2) )
      case case_1
      solve( Insert( <'F_status', ~n.6>, 'left' ) @ #t2 )
        case insertFstatussreq_0_111111211111111
        solve( State_111111211111111( lock, 'left', ~n.4, sk, status ) ▶₀ #t2 )
          case eventInitDevices_0_11111121111111
          solve( ((#vr.17 < #vr.35) ∧
                  (∃ #t2.
                    (Unlock_1( '1', ~n.7, ~n.5 ) @ #t2)
                   ∧
                    (#vr.17 < #t2) ∧
                    (#t2 < #vr.35) ∧
                    (∀ #t0 pp. (Unlock( pp, ~n.7, ~n.5 ) @ #t0) ⇒ #t0 = #t2) ∧
                    (∀ pp lpp #t0.
                      (Lock( pp, lpp, ~n.5 ) @ #t0)
                     ⇒
                      ((#t0 < #vr.17) ∨ (#t0 = #vr.17) ∨ (#t2 < #t0))) ∧
                    (∀ pp lpp #t0.
                      (Unlock( pp, lpp, ~n.5 ) @ #t0)
                     ⇒
                      ((#t0 < #vr.17) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                 (#vr.35 < #vr.17) )
            case case_2
            solve( (#vr.26 < #t2.1)  ∥ (#vr.26 = #t2.1) )
              case case_2
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( Unlock_0( '0', ~n.4, ~n.5 ) @ #t2.2 )
                  case unlocks_0_1111112111111111
                  solve( State_1111112111111111( ~n.4, req, ~n.5, sk, status ) ▶₀ #t2.2 )
                    case insertFstatussreq_0_111111211111111
                    solve( (#t2.1 < #t2.3)  ∥ (#t2.1 = #t2.3) )
                      case case_2
                      solve( !KU( aenc(<~n, y>, pk(~n.6)) ) @ #vk.1 )
                        case outaenclmrmpksk_0_1111211111
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma reachability_right:
  exists-trace "∃ x y #i #k. (Exclusive( x, y ) @ #i) ∧ (K( y ) @ #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ x y #i #k. (Exclusive( x, y ) @ #i) ∧ (K( y ) @ #k)"
*/
simplify
solve( State_111121111( x, y, s, sk ) ▶₀ #i )
  case newrm_0_11112111
  solve( !KU( ~n.1 ) @ #vk )
    case outy_0_1111112121111211
    solve( (#vr.27 < #t2)  ∥ (#vr.27 = #t2) )
      case case_1
      solve( Insert( <'F_status', ~n.6>, 'right' ) @ #t2 )
        case insertFstatussreq_0_1111112111111211
        solve( State_1111112111111211( lock, 'right', ~n.4, sk, status ) ▶₀ #t2 )
          case eventInitDevices_0_111111211111121
          solve( ((#vr.18 < #vr.37) ∧
                  (∃ #t2.
                    (Unlock_1( '1', ~n.7, ~n.5 ) @ #t2)
                   ∧
                    (#vr.18 < #t2) ∧
                    (#t2 < #vr.37) ∧
                    (∀ #t0 pp. (Unlock( pp, ~n.7, ~n.5 ) @ #t0) ⇒ #t0 = #t2) ∧
                    (∀ pp lpp #t0.
                      (Lock( pp, lpp, ~n.5 ) @ #t0)
                     ⇒
                      ((#t0 < #vr.18) ∨ (#t0 = #vr.18) ∨ (#t2 < #t0))) ∧
                    (∀ pp lpp #t0.
                      (Unlock( pp, lpp, ~n.5 ) @ #t0)
                     ⇒
                      ((#t0 < #vr.18) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                 (#vr.37 < #vr.18) )
            case case_2
            solve( (#vr.27 < #t2.1)  ∥ (#vr.27 = #t2.1) )
              case case_2
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( Unlock_0( '0', ~n.4, ~n.5 ) @ #t2.2 )
                  case unlocks_0_11111121111112111
                  solve( State_11111121111112111( ~n.4, req, ~n.5, sk, status ) ▶₀ #t2.2 )
                    case insertFstatussreq_0_1111112111111211
                    solve( (#t2.1 < #t2.3)  ∥ (#t2.1 = #t2.3) )
                      case case_2
                      solve( !KU( aenc(<x, ~n.1>, pk(~n.6)) ) @ #vk.1 )
                        case outaenclmrmpksk_0_1111211111
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma secrecy:
  all-traces
  "¬(∃ x y #i #k1 #k2.
      ((Exclusive( x, y ) @ #i) ∧ (K( x ) @ #k1)) ∧ (K( y ) @ #k2))"
/*
guarded formula characterizing all counter-examples:
"∃ x y #i #k1 #k2.
  (Exclusive( x, y ) @ #i) ∧ (K( x ) @ #k1) ∧ (K( y ) @ #k2)"
*/
simplify
solve( State_111121111( x, y, s, sk ) ▶₀ #i )
  case newrm_0_11112111
  solve( !KU( ~n ) @ #vk )
    case outaenclmrmpksk_0_1111211111
    by solve( !KU( ~n.3 ) @ #vk.2 )
  next
    case outx_0_111111212111111
    solve( (#vr.26 < #t2)  ∥ (#vr.26 = #t2) )
      case case_1
      solve( Insert( <'F_status', ~n.6>, 'left' ) @ #t2 )
        case insertFstatussreq_0_111111211111111
        solve( State_111111211111111( lock, 'left', ~n.4, sk, status ) ▶₀ #t2 )
          case eventInitDevices_0_11111121111111
          solve( ((#vr.17 < #vr.35) ∧
                  (∃ #t2.
                    (Unlock_1( '1', ~n.7, ~n.5 ) @ #t2)
                   ∧
                    (#vr.17 < #t2) ∧
                    (#t2 < #vr.35) ∧
                    (∀ #t0 pp. (Unlock( pp, ~n.7, ~n.5 ) @ #t0) ⇒ #t0 = #t2) ∧
                    (∀ pp lpp #t0.
                      (Lock( pp, lpp, ~n.5 ) @ #t0)
                     ⇒
                      ((#t0 < #vr.17) ∨ (#t0 = #vr.17) ∨ (#t2 < #t0))) ∧
                    (∀ pp lpp #t0.
                      (Unlock( pp, lpp, ~n.5 ) @ #t0)
                     ⇒
                      ((#t0 < #vr.17) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                 (#vr.35 < #vr.17) )
            case case_1
            solve( (#vr.26 < #t2.1)  ∥ (#vr.26 = #t2.1) )
              case case_1
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( State_111( ~n.5, sk ) ▶₀ #t2.1 )
                  case news_0_11
                  by contradiction /* cyclic */
                qed
              next
                case insertFstatussreq_0_111111211111111
                by solve( State_111111211111111( lock, 'init', ~n.5, sk, status
                          ) ▶₀ #t2.1 )
              next
                case insertFstatussreq_0_1111112111111211
                by solve( State_1111112111111211( lock, 'init', ~n.5, sk, status
                          ) ▶₀ #t2.1 )
              qed
            next
              case case_2
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( Unlock_1( '1', ~n.7, ~n.5 ) @ #t2.2 )
                  case unlocks_0_1111112121111111
                  by contradiction /* cyclic */
                next
                  case unlocks_0_11111121211112111
                  by contradiction /* cyclic */
                next
                  case unlocks_0_111111212111122
                  by contradiction /* cyclic */
                qed
              qed
            qed
          next
            case case_2
            solve( (#vr.26 < #t2.1)  ∥ (#vr.26 = #t2.1) )
              case case_1
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( State_111( ~n.5, sk ) ▶₀ #t2.1 )
                  case news_0_11
                  by contradiction /* cyclic */
                qed
              next
                case insertFstatussreq_0_111111211111111
                by solve( State_111111211111111( lock, 'init', ~n.5, sk, status
                          ) ▶₀ #t2.1 )
              next
                case insertFstatussreq_0_1111112111111211
                by solve( State_1111112111111211( lock, 'init', ~n.5, sk, status
                          ) ▶₀ #t2.1 )
              qed
            next
              case case_2
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( Unlock_0( '0', ~n.4, ~n.5 ) @ #t2.2 )
                  case unlocks_0_1111112111111111
                  solve( State_1111112111111111( ~n.4, req, ~n.5, sk, status ) ▶₀ #t2.2 )
                    case insertFstatussreq_0_111111211111111
                    solve( (#t2.1 < #t2.3)  ∥ (#t2.1 = #t2.3) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( !KU( ~n.1 ) @ #vk.1 )
                        case outaenclmrmpksk_0_1111211111
                        solve( !KU( aenc(<~n, y>, pk(~n.6)) ) @ #vk.2 )
                          case c_aenc
                          by contradiction /* cyclic */
                        next
                          case outaenclmrmpksk_0_1111211111
                          by solve( !KU( ~n.3 ) @ #vk.4 )
                        qed
                      next
                        case outx_0_111111212111111
                        solve( (#vr.51 < #t2.3)  ∥ (#vr.51 = #t2.3) )
                          case case_1
                          solve( Insert( <'F_status', ~n.10>, 'left' ) @ #t2.3 )
                            case insertFstatussreq_0_111111211111111
                            solve( State_111111211111111( lock, 'left', ~n.7, sk, status ) ▶₀ #t2.3 )
                              case eventInitDevices_0_11111121111111
                              solve( ((#vr.42 < #vr.60) ∧
                                      (∃ #t2.
                                        (Unlock_1( '1', ~n.11, ~n.8 ) @ #t2)
                                       ∧
                                        (#vr.42 < #t2) ∧
                                        (#t2 < #vr.60) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.11, ~n.8 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, ~n.8 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.42) ∨ (#t0 = #vr.42) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, ~n.8 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.42) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.60 < #vr.42) )
                                case case_1
                                solve( (#vr.51 < #t2.4)  ∥ (#vr.51 = #t2.4) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( State_111( ~n.8, sk ) ▶₀ #t2.4 )
                                      case news_0_11
                                      by contradiction /* cyclic */
                                    qed
                                  next
                                    case insertFstatussreq_0_111111211111111
                                    by solve( State_111111211111111( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    by solve( State_1111112111111211( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  qed
                                next
                                  case case_2
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( Unlock_1( '1', ~n.11, ~n.8 ) @ #t2.5 )
                                      case unlocks_0_1111112121111111
                                      by contradiction /* cyclic */
                                    next
                                      case unlocks_0_11111121211112111
                                      by contradiction /* cyclic */
                                    next
                                      case unlocks_0_111111212111122
                                      by contradiction /* cyclic */
                                    qed
                                  qed
                                qed
                              next
                                case case_2
                                solve( (#vr.51 < #t2.4)  ∥ (#vr.51 = #t2.4) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( State_111( ~n.8, sk ) ▶₀ #t2.4 )
                                      case news_0_11
                                      by contradiction /* cyclic */
                                    qed
                                  next
                                    case insertFstatussreq_0_111111211111111
                                    by solve( State_111111211111111( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    by solve( State_1111112111111211( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  qed
                                next
                                  case case_2
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( Unlock_0( '0', ~n.7, ~n.8 ) @ #t2.5 )
                                      case unlocks_0_1111112111111111
                                      solve( State_1111112111111111( ~n.7, req, ~n.8, sk, status ) ▶₀ #t2.5 )
                                        case insertFstatussreq_0_111111211111111
                                        solve( (#t2.4 < #t2.6)  ∥ (#t2.4 = #t2.6) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( !KU( aenc(<~n, y>, pk(~n.6)) ) @ #vk.2 )
                                            case c_aenc
                                            by contradiction /* cyclic */
                                          next
                                            case outaenclmrmpksk_0_1111211111
                                            solve( !KU( aenc(<~n.1, y>, pk(~n.7)) ) @ #vk.4 )
                                              case c_aenc
                                              by contradiction /* cyclic */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case unlocks_0_11111121111112111
                                      by solve( State_11111121111112111( ~n.7, req, ~n.8, sk, status
                                                ) ▶₀ #t2.5 )
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          next
                            case insertFstatussreq_0_1111112111111211
                            by solve( State_1111112111111211( lock, 'left', ~n.7, sk, status
                                      ) ▶₀ #t2.3 )
                          qed
                        next
                          case case_2
                          by solve( Insert( <'F_status', ~n.7>, 'left' ) @ #t2.3 )
                        qed
                      next
                        case outy_0_1111112121111211
                        solve( (#vr.52 < #t2.3)  ∥ (#vr.52 = #t2.3) )
                          case case_1
                          solve( Insert( <'F_status', ~n.10>, 'right' ) @ #t2.3 )
                            case insertFstatussreq_0_111111211111111
                            by solve( State_111111211111111( lock, 'right', ~n.7, sk, status
                                      ) ▶₀ #t2.3 )
                          next
                            case insertFstatussreq_0_1111112111111211
                            solve( State_1111112111111211( lock, 'right', ~n.7, sk, status
                                   ) ▶₀ #t2.3 )
                              case eventInitDevices_0_111111211111121
                              solve( ((#vr.43 < #vr.62) ∧
                                      (∃ #t2.
                                        (Unlock_1( '1', ~n.11, ~n.8 ) @ #t2)
                                       ∧
                                        (#vr.43 < #t2) ∧
                                        (#t2 < #vr.62) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.11, ~n.8 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, ~n.8 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.43) ∨ (#t0 = #vr.43) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, ~n.8 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.43) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.62 < #vr.43) )
                                case case_1
                                solve( (#vr.52 < #t2.4)  ∥ (#vr.52 = #t2.4) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( State_111( ~n.8, sk ) ▶₀ #t2.4 )
                                      case news_0_11
                                      by contradiction /* cyclic */
                                    qed
                                  next
                                    case insertFstatussreq_0_111111211111111
                                    by solve( State_111111211111111( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    by solve( State_1111112111111211( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  qed
                                next
                                  case case_2
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( Unlock_1( '1', ~n.11, ~n.8 ) @ #t2.5 )
                                      case unlocks_0_1111112121111111
                                      by contradiction /* cyclic */
                                    next
                                      case unlocks_0_11111121211112111
                                      by contradiction /* cyclic */
                                    next
                                      case unlocks_0_111111212111122
                                      by contradiction /* cyclic */
                                    qed
                                  qed
                                qed
                              next
                                case case_2
                                solve( (#vr.52 < #t2.4)  ∥ (#vr.52 = #t2.4) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( State_111( ~n.8, sk ) ▶₀ #t2.4 )
                                      case news_0_11
                                      by contradiction /* cyclic */
                                    qed
                                  next
                                    case insertFstatussreq_0_111111211111111
                                    by solve( State_111111211111111( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    by solve( State_1111112111111211( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  qed
                                next
                                  case case_2
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( Unlock_0( '0', ~n.7, ~n.8 ) @ #t2.5 )
                                      case unlocks_0_1111112111111111
                                      by solve( State_1111112111111111( ~n.7, req, ~n.8, sk, status
                                                ) ▶₀ #t2.5 )
                                    next
                                      case unlocks_0_11111121111112111
                                      solve( State_11111121111112111( ~n.7, req, ~n.8, sk, status ) ▶₀ #t2.5 )
                                        case insertFstatussreq_0_1111112111111211
                                        solve( (#t2.4 < #t2.6)  ∥ (#t2.4 = #t2.6) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( !KU( aenc(<~n, y>, pk(~n.6)) ) @ #vk.2 )
                                            case c_aenc
                                            by contradiction /* cyclic */
                                          next
                                            case outaenclmrmpksk_0_1111211111
                                            solve( !KU( aenc(<x, ~n.1>, pk(~n.7)) ) @ #vk.4 )
                                              case c_aenc
                                              by contradiction /* cyclic */
                                            next
                                              case outaenclmrmpksk_0_1111211111
                                              by contradiction /* cyclic */
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        next
                          case case_2
                          by solve( Insert( <'F_status', ~n.7>, 'right' ) @ #t2.3 )
                        qed
                      qed
                    qed
                  qed
                next
                  case unlocks_0_11111121111112111
                  by solve( State_11111121111112111( ~n.4, req, ~n.5, sk, status
                            ) ▶₀ #t2.2 )
                qed
              qed
            qed
          qed
        qed
      next
        case insertFstatussreq_0_1111112111111211
        by solve( State_1111112111111211( lock, 'left', ~n.4, sk, status
                  ) ▶₀ #t2 )
      qed
    next
      case case_2
      by solve( Insert( <'F_status', ~n.4>, 'left' ) @ #t2 )
    qed
  next
    case outy_0_1111112121111211
    solve( (#vr.27 < #t2)  ∥ (#vr.27 = #t2) )
      case case_1
      solve( Insert( <'F_status', ~n.6>, 'right' ) @ #t2 )
        case insertFstatussreq_0_111111211111111
        by solve( State_111111211111111( lock, 'right', ~n.4, sk, status
                  ) ▶₀ #t2 )
      next
        case insertFstatussreq_0_1111112111111211
        solve( State_1111112111111211( lock, 'right', ~n.4, sk, status ) ▶₀ #t2 )
          case eventInitDevices_0_111111211111121
          solve( ((#vr.18 < #vr.37) ∧
                  (∃ #t2.
                    (Unlock_1( '1', ~n.7, ~n.5 ) @ #t2)
                   ∧
                    (#vr.18 < #t2) ∧
                    (#t2 < #vr.37) ∧
                    (∀ #t0 pp. (Unlock( pp, ~n.7, ~n.5 ) @ #t0) ⇒ #t0 = #t2) ∧
                    (∀ pp lpp #t0.
                      (Lock( pp, lpp, ~n.5 ) @ #t0)
                     ⇒
                      ((#t0 < #vr.18) ∨ (#t0 = #vr.18) ∨ (#t2 < #t0))) ∧
                    (∀ pp lpp #t0.
                      (Unlock( pp, lpp, ~n.5 ) @ #t0)
                     ⇒
                      ((#t0 < #vr.18) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                 (#vr.37 < #vr.18) )
            case case_1
            solve( (#vr.27 < #t2.1)  ∥ (#vr.27 = #t2.1) )
              case case_1
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( State_111( ~n.5, sk ) ▶₀ #t2.1 )
                  case news_0_11
                  by contradiction /* cyclic */
                qed
              next
                case insertFstatussreq_0_111111211111111
                by solve( State_111111211111111( lock, 'init', ~n.5, sk, status
                          ) ▶₀ #t2.1 )
              next
                case insertFstatussreq_0_1111112111111211
                by solve( State_1111112111111211( lock, 'init', ~n.5, sk, status
                          ) ▶₀ #t2.1 )
              qed
            next
              case case_2
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( Unlock_1( '1', ~n.7, ~n.5 ) @ #t2.2 )
                  case unlocks_0_1111112121111111
                  by contradiction /* cyclic */
                next
                  case unlocks_0_11111121211112111
                  by contradiction /* cyclic */
                next
                  case unlocks_0_111111212111122
                  by contradiction /* cyclic */
                qed
              qed
            qed
          next
            case case_2
            solve( (#vr.27 < #t2.1)  ∥ (#vr.27 = #t2.1) )
              case case_1
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( State_111( ~n.5, sk ) ▶₀ #t2.1 )
                  case news_0_11
                  by contradiction /* cyclic */
                qed
              next
                case insertFstatussreq_0_111111211111111
                by solve( State_111111211111111( lock, 'init', ~n.5, sk, status
                          ) ▶₀ #t2.1 )
              next
                case insertFstatussreq_0_1111112111111211
                by solve( State_1111112111111211( lock, 'init', ~n.5, sk, status
                          ) ▶₀ #t2.1 )
              qed
            next
              case case_2
              solve( Insert( <'F_status', ~n.5>, 'init' ) @ #t2.1 )
                case insertFstatussinit_0_111
                solve( Unlock_0( '0', ~n.4, ~n.5 ) @ #t2.2 )
                  case unlocks_0_1111112111111111
                  by solve( State_1111112111111111( ~n.4, req, ~n.5, sk, status
                            ) ▶₀ #t2.2 )
                next
                  case unlocks_0_11111121111112111
                  solve( State_11111121111112111( ~n.4, req, ~n.5, sk, status ) ▶₀ #t2.2 )
                    case insertFstatussreq_0_1111112111111211
                    solve( (#t2.1 < #t2.3)  ∥ (#t2.1 = #t2.3) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( !KU( ~n.1 ) @ #vk.1 )
                        case outaenclmrmpksk_0_1111211111
                        solve( !KU( aenc(<x, ~n>, pk(~n.6)) ) @ #vk.2 )
                          case c_aenc
                          by contradiction /* cyclic */
                        qed
                      next
                        case outx_0_111111212111111
                        solve( (#vr.53 < #t2.3)  ∥ (#vr.53 = #t2.3) )
                          case case_1
                          solve( Insert( <'F_status', ~n.10>, 'left' ) @ #t2.3 )
                            case insertFstatussreq_0_111111211111111
                            solve( State_111111211111111( lock, 'left', ~n.7, sk, status ) ▶₀ #t2.3 )
                              case eventInitDevices_0_11111121111111
                              solve( ((#vr.44 < #vr.62) ∧
                                      (∃ #t2.
                                        (Unlock_1( '1', ~n.11, ~n.8 ) @ #t2)
                                       ∧
                                        (#vr.44 < #t2) ∧
                                        (#t2 < #vr.62) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.11, ~n.8 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, ~n.8 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.44) ∨ (#t0 = #vr.44) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, ~n.8 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.44) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.62 < #vr.44) )
                                case case_1
                                solve( (#vr.53 < #t2.4)  ∥ (#vr.53 = #t2.4) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( State_111( ~n.8, sk ) ▶₀ #t2.4 )
                                      case news_0_11
                                      by contradiction /* cyclic */
                                    qed
                                  next
                                    case insertFstatussreq_0_111111211111111
                                    by solve( State_111111211111111( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    by solve( State_1111112111111211( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  qed
                                next
                                  case case_2
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( Unlock_1( '1', ~n.11, ~n.8 ) @ #t2.5 )
                                      case unlocks_0_1111112121111111
                                      by contradiction /* cyclic */
                                    next
                                      case unlocks_0_11111121211112111
                                      by contradiction /* cyclic */
                                    next
                                      case unlocks_0_111111212111122
                                      by contradiction /* cyclic */
                                    qed
                                  qed
                                qed
                              next
                                case case_2
                                solve( (#vr.53 < #t2.4)  ∥ (#vr.53 = #t2.4) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( State_111( ~n.8, sk ) ▶₀ #t2.4 )
                                      case news_0_11
                                      by contradiction /* cyclic */
                                    qed
                                  next
                                    case insertFstatussreq_0_111111211111111
                                    by solve( State_111111211111111( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    by solve( State_1111112111111211( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  qed
                                next
                                  case case_2
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( Unlock_0( '0', ~n.7, ~n.8 ) @ #t2.5 )
                                      case unlocks_0_1111112111111111
                                      solve( State_1111112111111111( ~n.7, req, ~n.8, sk, status ) ▶₀ #t2.5 )
                                        case insertFstatussreq_0_111111211111111
                                        solve( (#t2.4 < #t2.6)  ∥ (#t2.4 = #t2.6) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( !KU( aenc(<x, ~n>, pk(~n.6)) ) @ #vk.2 )
                                            case c_aenc
                                            by contradiction /* cyclic */
                                          qed
                                        qed
                                      qed
                                    next
                                      case unlocks_0_11111121111112111
                                      by solve( State_11111121111112111( ~n.7, req, ~n.8, sk, status
                                                ) ▶₀ #t2.5 )
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          next
                            case insertFstatussreq_0_1111112111111211
                            by solve( State_1111112111111211( lock, 'left', ~n.7, sk, status
                                      ) ▶₀ #t2.3 )
                          qed
                        next
                          case case_2
                          by solve( Insert( <'F_status', ~n.7>, 'left' ) @ #t2.3 )
                        qed
                      next
                        case outy_0_1111112121111211
                        solve( (#vr.54 < #t2.3)  ∥ (#vr.54 = #t2.3) )
                          case case_1
                          solve( Insert( <'F_status', ~n.10>, 'right' ) @ #t2.3 )
                            case insertFstatussreq_0_111111211111111
                            by solve( State_111111211111111( lock, 'right', ~n.7, sk, status
                                      ) ▶₀ #t2.3 )
                          next
                            case insertFstatussreq_0_1111112111111211
                            solve( State_1111112111111211( lock, 'right', ~n.7, sk, status
                                   ) ▶₀ #t2.3 )
                              case eventInitDevices_0_111111211111121
                              solve( ((#vr.45 < #vr.64) ∧
                                      (∃ #t2.
                                        (Unlock_1( '1', ~n.11, ~n.8 ) @ #t2)
                                       ∧
                                        (#vr.45 < #t2) ∧
                                        (#t2 < #vr.64) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.11, ~n.8 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, ~n.8 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.45) ∨ (#t0 = #vr.45) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, ~n.8 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.45) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.64 < #vr.45) )
                                case case_1
                                solve( (#vr.54 < #t2.4)  ∥ (#vr.54 = #t2.4) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( State_111( ~n.8, sk ) ▶₀ #t2.4 )
                                      case news_0_11
                                      by contradiction /* cyclic */
                                    qed
                                  next
                                    case insertFstatussreq_0_111111211111111
                                    by solve( State_111111211111111( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    by solve( State_1111112111111211( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  qed
                                next
                                  case case_2
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( Unlock_1( '1', ~n.11, ~n.8 ) @ #t2.5 )
                                      case unlocks_0_1111112121111111
                                      by contradiction /* cyclic */
                                    next
                                      case unlocks_0_11111121211112111
                                      by contradiction /* cyclic */
                                    next
                                      case unlocks_0_111111212111122
                                      by contradiction /* cyclic */
                                    qed
                                  qed
                                qed
                              next
                                case case_2
                                solve( (#vr.54 < #t2.4)  ∥ (#vr.54 = #t2.4) )
                                  case case_1
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( State_111( ~n.8, sk ) ▶₀ #t2.4 )
                                      case news_0_11
                                      by contradiction /* cyclic */
                                    qed
                                  next
                                    case insertFstatussreq_0_111111211111111
                                    by solve( State_111111211111111( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  next
                                    case insertFstatussreq_0_1111112111111211
                                    by solve( State_1111112111111211( lock, 'init', ~n.8, sk, status
                                              ) ▶₀ #t2.4 )
                                  qed
                                next
                                  case case_2
                                  solve( Insert( <'F_status', ~n.8>, 'init' ) @ #t2.4 )
                                    case insertFstatussinit_0_111
                                    solve( Unlock_0( '0', ~n.7, ~n.8 ) @ #t2.5 )
                                      case unlocks_0_1111112111111111
                                      by solve( State_1111112111111111( ~n.7, req, ~n.8, sk, status
                                                ) ▶₀ #t2.5 )
                                    next
                                      case unlocks_0_11111121111112111
                                      solve( State_11111121111112111( ~n.7, req, ~n.8, sk, status ) ▶₀ #t2.5 )
                                        case insertFstatussreq_0_1111112111111211
                                        solve( (#t2.4 < #t2.6)  ∥ (#t2.4 = #t2.6) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( !KU( aenc(<x, ~n>, pk(~n.6)) ) @ #vk.2 )
                                            case c_aenc
                                            by contradiction /* cyclic */
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        next
                          case case_2
                          by solve( Insert( <'F_status', ~n.7>, 'right' ) @ #t2.3 )
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case case_2
      by solve( Insert( <'F_status', ~n.4>, 'right' ) @ #t2 )
    qed
  qed
qed













rule (modulo E) Init[color=#ffffff, process='!', issapicrule,
                     role='Process']:
   [ ] --[ Init( ) ]-> [ State_( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_[color=#ffffff, process='!', issapicrule,
                     role='Process']:
   [ State_( ) ] --> [ !Semistate_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_[color=#ffffff, process='!', issapicrule,
                     role='Process']:
   [ !Semistate_1( ) ] --> [ State_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) newsk_0_1[color=#ffffff, process='new sk.1;',
                          issapicrule, role='Process']:
   [ State_1( ), Fr( sk.1 ) ] --> [ State_11( sk.1 ) ]

  /*
  rule (modulo AC) newsk_0_1[color=#ffffff, process='new sk.1;',
                             issapicrule, role='Process']:
     [ State_1( ), Fr( sk ) ] --> [ State_11( sk ) ]
  */

rule (modulo E) news_0_11[color=#ffffff, process='new s.1;', issapicrule,
                          role='Process']:
   [ State_11( sk.1 ), Fr( s.1 ) ] --> [ State_111( s.1, sk.1 ) ]

  /*
  rule (modulo AC) news_0_11[color=#ffffff, process='new s.1;',
                             issapicrule, role='Process']:
     [ State_11( sk ), Fr( s ) ] --> [ State_111( s, sk ) ]
  */

rule (modulo E) insertFstatussinit_0_111[color=#ffffff,
                                         process='insert <'F_status', s.1>,'init';', issapicrule,
                                         role='Process']:
   [ State_111( s.1, sk.1 ) ]
  --[ Insert( <'F_status', s.1>, 'init' ) ]->
   [ State_1111( s.1, sk.1 ) ]

  /*
  rule (modulo AC) insertFstatussinit_0_111[color=#ffffff,
                                            process='insert <'F_status', s.1>,'init';', issapicrule,
                                            role='Process']:
     [ State_111( s, sk ) ]
    --[ Insert( <'F_status', s>, 'init' ) ]->
     [ State_1111( s, sk ) ]
  */

rule (modulo E) p_0_1111[color=#ffffff, process='|', issapicrule,
                         role='Process']:
   [ State_1111( s.1, sk.1 ) ]
  -->
   [ State_11111( s.1, sk.1 ), State_11112( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_0_1111[color=#ffffff, process='|', issapicrule,
                            role='Process']:
     [ State_1111( s, sk ) ]
    -->
     [ State_11111( s, sk ), State_11112( s, sk ) ]
  */

rule (modulo E) Device_0_11111[color=#ffffff, process='Device()',
                               issapicrule, role='Process']:
   [ State_11111( s.1, sk.1 ) ]
  -->
   [ State_111111( s.1, sk.1 ), State_111112( s.1, sk.1 ) ]

  /*
  rule (modulo AC) Device_0_11111[color=#ffffff, process='Device()',
                                  issapicrule, role='Process']:
     [ State_11111( s, sk ) ]
    -->
     [ State_111111( s, sk ), State_111112( s, sk ) ]
  */

rule (modulo E) p_0_111111[color=#708040, process='|', issapicrule,
                           role='Device']:
   [ State_111111( s.1, sk.1 ) ]
  -->
   [ State_1111111( s.1, sk.1 ), State_1111112( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_0_111111[color=#708040, process='|', issapicrule,
                              role='Device']:
     [ State_111111( s, sk ) ]
    -->
     [ State_1111111( s, sk ), State_1111112( s, sk ) ]
  */

rule (modulo E) outpksk_0_1111111[color=#708040,
                                  process='out(pk(sk.1));', issapicrule, role='Device']:
   [ State_1111111( s.1, sk.1 ) ]
  -->
   [ State_11111111( s.1, sk.1 ), Out( pk(sk.1) ) ]

  /*
  rule (modulo AC) outpksk_0_1111111[color=#708040,
                                     process='out(pk(sk.1));', issapicrule, role='Device']:
     [ State_1111111( s, sk ) ] --> [ State_11111111( s, sk ), Out( pk(sk) ) ]
  */

rule (modulo E) p_0_11111111[color=#708040, process='0', issapicrule,
                             role='Device']:
   [ State_11111111( s.1, sk.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11111111[color=#708040, process='0', issapicrule,
                                role='Device']:
     [ State_11111111( s, sk ) ] --> [ ]
  */

rule (modulo E) p_0_1111112[color=#708040, process='!', issapicrule,
                            role='Device']:
   [ State_1111112( s.1, sk.1 ) ] --> [ !Semistate_11111121( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_0_1111112[color=#708040, process='!', issapicrule,
                               role='Device']:
     [ State_1111112( s, sk ) ] --> [ !Semistate_11111121( s, sk ) ]
  */

rule (modulo E) p_1_1111112[color=#708040, process='!', issapicrule,
                            role='Device']:
   [ !Semistate_11111121( s.1, sk.1 ) ] --> [ State_11111121( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_1_1111112[color=#708040, process='!', issapicrule,
                               role='Device']:
     [ !Semistate_11111121( s, sk ) ] --> [ State_11111121( s, sk ) ]
  */

rule (modulo E) p_0_11111121[color=#708040, process='|', issapicrule,
                             role='Device']:
   [ State_11111121( s.1, sk.1 ) ]
  -->
   [ State_111111211( s.1, sk.1 ), State_111111212( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_0_11111121[color=#708040, process='|', issapicrule,
                                role='Device']:
     [ State_11111121( s, sk ) ]
    -->
     [ State_111111211( s, sk ), State_111111212( s, sk ) ]
  */

rule (modulo E) locks_0_111111211[color=#708040, process='lock s.1;',
                                  issapicrule, role='Device']:
   [ State_111111211( s.1, sk.1 ), Fr( lock ) ]
  --[ Lock_0( '0', lock, s.1 ), Lock( '0', lock, s.1 ) ]->
   [ State_1111112111( lock, s.1, sk.1 ) ]

  /*
  rule (modulo AC) locks_0_111111211[color=#708040, process='lock s.1;',
                                     issapicrule, role='Device']:
     [ State_111111211( s, sk ), Fr( lock ) ]
    --[ Lock_0( '0', lock, s ), Lock( '0', lock, s ) ]->
     [ State_1111112111( lock, s, sk ) ]
  */

rule (modulo E) inreq_0_1111112111[color=#708040, process='in(req.1);',
                                   issapicrule, role='Device']:
   [ State_1111112111( lock, s.1, sk.1 ), In( req.1 ) ]
  -->
   [ State_11111121111( lock, req.1, s.1, sk.1 ) ]

  /*
  rule (modulo AC) inreq_0_1111112111[color=#708040, process='in(req.1);',
                                      issapicrule, role='Device']:
     [ State_1111112111( lock, s, sk ), In( req ) ]
    -->
     [ State_11111121111( lock, req, s, sk ) ]
  */

rule (modulo E) lookupFstatussasstatus_0_11111121111[color=#708040,
                                                     process='lookup <'F_status', s.1> as status.1',
                                                     no_derivcheck, issapicrule, role='Device']:
   [ State_11111121111( lock, req.1, s.1, sk.1 ) ]
  --[ IsIn( <'F_status', s.1>, status.1 ) ]->
   [ State_111111211111( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) lookupFstatussasstatus_0_11111121111[color=#708040,
                                                        process='lookup <'F_status', s.1> as status.1',
                                                        no_derivcheck, issapicrule, role='Device']:
     [ State_11111121111( lock, req, s, sk ) ]
    --[ IsIn( <'F_status', s>, status ) ]->
     [ State_111111211111( lock, req, s, sk, status ) ]
  */

rule (modulo E) lookupFstatussasstatus_1_11111121111[color=#708040,
                                                     process='lookup <'F_status', s.1> as status.1',
                                                     no_derivcheck, issapicrule, role='Device']:
   [ State_11111121111( lock, req.1, s.1, sk.1 ) ]
  --[ IsNotSet( <'F_status', s.1> ) ]->
   [ State_111111211112( lock, req.1, s.1, sk.1 ) ]

  /*
  rule (modulo AC) lookupFstatussasstatus_1_11111121111[color=#708040,
                                                        process='lookup <'F_status', s.1> as status.1',
                                                        no_derivcheck, issapicrule, role='Device']:
     [ State_11111121111( lock, req, s, sk ) ]
    --[ IsNotSet( <'F_status', s> ) ]->
     [ State_111111211112( lock, req, s, sk ) ]
  */

rule (modulo E) ifstatusinit_0_111111211111[color=#708040,
                                            process='if status.1='init'', issapicrule, role='Device']:
   [ State_111111211111( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Pred_Eq( status.1, 'init' ) ]->
   [ State_1111112111111( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) ifstatusinit_0_111111211111[color=#708040,
                                               process='if status.1='init'', issapicrule, role='Device']:
     [ State_111111211111( lock, req, s, sk, status ) ]
    --[ Pred_Eq( status, 'init' ) ]->
     [ State_1111112111111( lock, req, s, sk, status ) ]
  */

rule (modulo E) ifstatusinit_1_111111211111[color=#708040,
                                            process='if status.1='init'', issapicrule, role='Device']:
   [ State_111111211111( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Pred_Not_Eq( status.1, 'init' ) ]->
   [ State_1111112111112( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) ifstatusinit_1_111111211111[color=#708040,
                                               process='if status.1='init'', issapicrule, role='Device']:
     [ State_111111211111( lock, req, s, sk, status ) ]
    --[ Pred_Not_Eq( status, 'init' ) ]->
     [ State_1111112111112( lock, req, s, sk, status ) ]
  */

rule (modulo E) ifreqleft_0_1111112111111[color=#708040,
                                          process='if req.1='left'', issapicrule, role='Device']:
   [ State_1111112111111( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Pred_Eq( req.1, 'left' ) ]->
   [ State_11111121111111( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) ifreqleft_0_1111112111111[color=#708040,
                                             process='if req.1='left'', issapicrule, role='Device']:
     [ State_1111112111111( lock, req, s, sk, status ) ]
    --[ Pred_Eq( req, 'left' ) ]->
     [ State_11111121111111( lock, req, s, sk, status ) ]
  */

rule (modulo E) ifreqleft_1_1111112111111[color=#708040,
                                          process='if req.1='left'', issapicrule, role='Device']:
   [ State_1111112111111( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Pred_Not_Eq( req.1, 'left' ) ]->
   [ State_11111121111112( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) ifreqleft_1_1111112111111[color=#708040,
                                             process='if req.1='left'', issapicrule, role='Device']:
     [ State_1111112111111( lock, req, s, sk, status ) ]
    --[ Pred_Not_Eq( req, 'left' ) ]->
     [ State_11111121111112( lock, req, s, sk, status ) ]
  */

rule (modulo E) eventInitDevices_0_11111121111111[color=#708040,
                                                  process='event InitDevice( s.1 );', issapicrule,
                                                  role='Device']:
   [ State_11111121111111( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ InitDevice( s.1 ) ]->
   [ State_111111211111111( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) eventInitDevices_0_11111121111111[color=#708040,
                                                     process='event InitDevice( s.1 );', issapicrule,
                                                     role='Device']:
     [ State_11111121111111( lock, req, s, sk, status ) ]
    --[ InitDevice( s ) ]->
     [ State_111111211111111( lock, req, s, sk, status ) ]
  */

rule (modulo E) insertFstatussreq_0_111111211111111[color=#708040,
                                                    process='insert <'F_status', s.1>,req.1;', issapicrule,
                                                    role='Device']:
   [ State_111111211111111( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Insert( <'F_status', s.1>, req.1 ) ]->
   [ State_1111112111111111( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) insertFstatussreq_0_111111211111111[color=#708040,
                                                       process='insert <'F_status', s.1>,req.1;', issapicrule,
                                                       role='Device']:
     [ State_111111211111111( lock, req, s, sk, status ) ]
    --[ Insert( <'F_status', s>, req ) ]->
     [ State_1111112111111111( lock, req, s, sk, status ) ]
  */

rule (modulo E) unlocks_0_1111112111111111[color=#708040,
                                           process='unlock s.1;', issapicrule, role='Device']:
   [ State_1111112111111111( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Unlock_0( '0', lock, s.1 ), Unlock( '0', lock, s.1 ) ]->
   [ State_11111121111111111( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) unlocks_0_1111112111111111[color=#708040,
                                              process='unlock s.1;', issapicrule, role='Device']:
     [ State_1111112111111111( lock, req, s, sk, status ) ]
    --[ Unlock_0( '0', lock, s ), Unlock( '0', lock, s ) ]->
     [ State_11111121111111111( lock, req, s, sk, status ) ]
  */

rule (modulo E) p_0_11111121111111111[color=#708040, process='0',
                                      issapicrule, role='Device']:
   [ State_11111121111111111( lock, req.1, s.1, sk.1, status.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11111121111111111[color=#708040, process='0',
                                         issapicrule, role='Device']:
     [ State_11111121111111111( lock, req, s, sk, status ) ] --> [ ]
  */

rule (modulo E) ifreqright_0_11111121111112[color=#708040,
                                            process='if req.1='right'', issapicrule, role='Device']:
   [ State_11111121111112( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Pred_Eq( req.1, 'right' ) ]->
   [ State_111111211111121( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) ifreqright_0_11111121111112[color=#708040,
                                               process='if req.1='right'', issapicrule, role='Device']:
     [ State_11111121111112( lock, req, s, sk, status ) ]
    --[ Pred_Eq( req, 'right' ) ]->
     [ State_111111211111121( lock, req, s, sk, status ) ]
  */

rule (modulo E) ifreqright_1_11111121111112[color=#708040,
                                            process='if req.1='right'', issapicrule, role='Device']:
   [ State_11111121111112( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Pred_Not_Eq( req.1, 'right' ) ]->
   [ State_111111211111122( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) ifreqright_1_11111121111112[color=#708040,
                                               process='if req.1='right'', issapicrule, role='Device']:
     [ State_11111121111112( lock, req, s, sk, status ) ]
    --[ Pred_Not_Eq( req, 'right' ) ]->
     [ State_111111211111122( lock, req, s, sk, status ) ]
  */

rule (modulo E) eventInitDevices_0_111111211111121[color=#708040,
                                                   process='event InitDevice( s.1 );', issapicrule,
                                                   role='Device']:
   [ State_111111211111121( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ InitDevice( s.1 ) ]->
   [ State_1111112111111211( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) eventInitDevices_0_111111211111121[color=#708040,
                                                      process='event InitDevice( s.1 );', issapicrule,
                                                      role='Device']:
     [ State_111111211111121( lock, req, s, sk, status ) ]
    --[ InitDevice( s ) ]->
     [ State_1111112111111211( lock, req, s, sk, status ) ]
  */

rule (modulo E) insertFstatussreq_0_1111112111111211[color=#708040,
                                                     process='insert <'F_status', s.1>,req.1;', issapicrule,
                                                     role='Device']:
   [ State_1111112111111211( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Insert( <'F_status', s.1>, req.1 ) ]->
   [ State_11111121111112111( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) insertFstatussreq_0_1111112111111211[color=#708040,
                                                        process='insert <'F_status', s.1>,req.1;',
                                                        issapicrule, role='Device']:
     [ State_1111112111111211( lock, req, s, sk, status ) ]
    --[ Insert( <'F_status', s>, req ) ]->
     [ State_11111121111112111( lock, req, s, sk, status ) ]
  */

rule (modulo E) unlocks_0_11111121111112111[color=#708040,
                                            process='unlock s.1;', issapicrule, role='Device']:
   [ State_11111121111112111( lock, req.1, s.1, sk.1, status.1 ) ]
  --[ Unlock_0( '0', lock, s.1 ), Unlock( '0', lock, s.1 ) ]->
   [ State_111111211111121111( lock, req.1, s.1, sk.1, status.1 ) ]

  /*
  rule (modulo AC) unlocks_0_11111121111112111[color=#708040,
                                               process='unlock s.1;', issapicrule, role='Device']:
     [ State_11111121111112111( lock, req, s, sk, status ) ]
    --[ Unlock_0( '0', lock, s ), Unlock( '0', lock, s ) ]->
     [ State_111111211111121111( lock, req, s, sk, status ) ]
  */

rule (modulo E) p_0_111111211111121111[color=#708040, process='0',
                                       issapicrule, role='Device']:
   [ State_111111211111121111( lock, req.1, s.1, sk.1, status.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111111211111121111[color=#708040, process='0',
                                          issapicrule, role='Device']:
     [ State_111111211111121111( lock, req, s, sk, status ) ] --> [ ]
  */

rule (modulo E) p_0_111111211111122[color=#708040, process='0',
                                    issapicrule, role='Device']:
   [ State_111111211111122( lock, req.1, s.1, sk.1, status.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111111211111122[color=#708040, process='0',
                                       issapicrule, role='Device']:
     [ State_111111211111122( lock, req, s, sk, status ) ] --> [ ]
  */

rule (modulo E) p_0_1111112111112[color=#708040, process='0',
                                  issapicrule, role='Device']:
   [ State_1111112111112( lock, req.1, s.1, sk.1, status.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111112111112[color=#708040, process='0',
                                     issapicrule, role='Device']:
     [ State_1111112111112( lock, req, s, sk, status ) ] --> [ ]
  */

rule (modulo E) p_0_111111211112[color=#708040, process='0', issapicrule,
                                 role='Device']:
   [ State_111111211112( lock, req.1, s.1, sk.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111111211112[color=#708040, process='0',
                                    issapicrule, role='Device']:
     [ State_111111211112( lock, req, s, sk ) ] --> [ ]
  */

rule (modulo E) p_0_111111212[color=#708040, process='!', issapicrule,
                              role='Device']:
   [ State_111111212( s.1, sk.1 ) ]
  -->
   [ !Semistate_1111112121( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_0_111111212[color=#708040, process='!', issapicrule,
                                 role='Device']:
     [ State_111111212( s, sk ) ] --> [ !Semistate_1111112121( s, sk ) ]
  */

rule (modulo E) p_1_111111212[color=#708040, process='!', issapicrule,
                              role='Device']:
   [ !Semistate_1111112121( s.1, sk.1 ) ]
  -->
   [ State_1111112121( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_1_111111212[color=#708040, process='!', issapicrule,
                                 role='Device']:
     [ !Semistate_1111112121( s, sk ) ] --> [ State_1111112121( s, sk ) ]
  */

rule (modulo E) locks_0_1111112121[color=#708040, process='lock s.1;',
                                   issapicrule, role='Device']:
   [ State_1111112121( s.1, sk.1 ), Fr( lock.1 ) ]
  --[ Lock_1( '1', lock.1, s.1 ), Lock( '1', lock.1, s.1 ) ]->
   [ State_11111121211( lock.1, s.1, sk.1 ) ]

  /*
  rule (modulo AC) locks_0_1111112121[color=#708040, process='lock s.1;',
                                      issapicrule, role='Device']:
     [ State_1111112121( s, sk ), Fr( lock ) ]
    --[ Lock_1( '1', lock, s ), Lock( '1', lock, s ) ]->
     [ State_11111121211( lock, s, sk ) ]
  */

rule (modulo E) inaencxypksk_0_11111121211[color=#708040,
                                           process='in(aenc(<x.1, y.1>, pk(=sk.1)));', issapicrule,
                                           role='Device']:
   [
   State_11111121211( lock.1, s.1, sk.1 ), In( aenc(<x.1, y.1>, pk(sk.1)) )
   ]
  -->
   [ State_111111212111( lock.1, s.1, sk.1, x.1, y.1 ) ]

  /*
  rule (modulo AC) inaencxypksk_0_11111121211[color=#708040,
                                              process='in(aenc(<x.1, y.1>, pk(=sk.1)));', issapicrule,
                                              role='Device']:
     [ State_11111121211( lock, s, sk ), In( aenc(<x, y>, pk(sk)) ) ]
    -->
     [ State_111111212111( lock, s, sk, x, y ) ]
  */

rule (modulo E) lookupFstatussasstatus_0_111111212111[color=#708040,
                                                      process='lookup <'F_status', s.1> as status.2',
                                                      no_derivcheck, issapicrule, role='Device']:
   [ State_111111212111( lock.1, s.1, sk.1, x.1, y.1 ) ]
  --[ IsIn( <'F_status', s.1>, status.2 ) ]->
   [ State_1111112121111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) lookupFstatussasstatus_0_111111212111[color=#708040,
                                                         process='lookup <'F_status', s.1> as status.2',
                                                         no_derivcheck, issapicrule, role='Device']:
     [ State_111111212111( lock, s, sk, x, y ) ]
    --[ IsIn( <'F_status', s>, status ) ]->
     [ State_1111112121111( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) lookupFstatussasstatus_1_111111212111[color=#708040,
                                                      process='lookup <'F_status', s.1> as status.2',
                                                      no_derivcheck, issapicrule, role='Device']:
   [ State_111111212111( lock.1, s.1, sk.1, x.1, y.1 ) ]
  --[ IsNotSet( <'F_status', s.1> ) ]->
   [ State_1111112121112( lock.1, s.1, sk.1, x.1, y.1 ) ]

  /*
  rule (modulo AC) lookupFstatussasstatus_1_111111212111[color=#708040,
                                                         process='lookup <'F_status', s.1> as status.2',
                                                         no_derivcheck, issapicrule, role='Device']:
     [ State_111111212111( lock, s, sk, x, y ) ]
    --[ IsNotSet( <'F_status', s> ) ]->
     [ State_1111112121112( lock, s, sk, x, y ) ]
  */

rule (modulo E) ifstatusleft_0_1111112121111[color=#708040,
                                             process='if status.2='left'', issapicrule, role='Device']:
   [ State_1111112121111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Pred_Eq( status.2, 'left' ) ]->
   [ State_11111121211111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) ifstatusleft_0_1111112121111[color=#708040,
                                                process='if status.2='left'', issapicrule, role='Device']:
     [ State_1111112121111( lock, s, sk, x, y, status ) ]
    --[ Pred_Eq( status, 'left' ) ]->
     [ State_11111121211111( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) ifstatusleft_1_1111112121111[color=#708040,
                                             process='if status.2='left'', issapicrule, role='Device']:
   [ State_1111112121111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Pred_Not_Eq( status.2, 'left' ) ]->
   [ State_11111121211112( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) ifstatusleft_1_1111112121111[color=#708040,
                                                process='if status.2='left'', issapicrule, role='Device']:
     [ State_1111112121111( lock, s, sk, x, y, status ) ]
    --[ Pred_Not_Eq( status, 'left' ) ]->
     [ State_11111121211112( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) eventAccessx_0_11111121211111[color=#708040,
                                              process='event Access( x.1 );', issapicrule, role='Device']:
   [ State_11111121211111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Access( x.1 ) ]->
   [ State_111111212111111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) eventAccessx_0_11111121211111[color=#708040,
                                                 process='event Access( x.1 );', issapicrule, role='Device']:
     [ State_11111121211111( lock, s, sk, x, y, status ) ]
    --[ Access( x ) ]->
     [ State_111111212111111( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) outx_0_111111212111111[color=#708040,
                                       process='out(x.1);', issapicrule, role='Device']:
   [ State_111111212111111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  -->
   [
   State_1111112121111111( lock.1, s.1, sk.1, x.1, y.1, status.2 ),
   Out( x.1 )
   ]

  /*
  rule (modulo AC) outx_0_111111212111111[color=#708040,
                                          process='out(x.1);', issapicrule, role='Device']:
     [ State_111111212111111( lock, s, sk, x, y, status ) ]
    -->
     [ State_1111112121111111( lock, s, sk, x, y, status ), Out( x ) ]
  */

rule (modulo E) unlocks_0_1111112121111111[color=#708040,
                                           process='unlock s.1;', issapicrule, role='Device']:
   [ State_1111112121111111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Unlock_1( '1', lock.1, s.1 ), Unlock( '1', lock.1, s.1 ) ]->
   [ State_11111121211111111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) unlocks_0_1111112121111111[color=#708040,
                                              process='unlock s.1;', issapicrule, role='Device']:
     [ State_1111112121111111( lock, s, sk, x, y, status ) ]
    --[ Unlock_1( '1', lock, s ), Unlock( '1', lock, s ) ]->
     [ State_11111121211111111( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) p_0_11111121211111111[color=#708040, process='0',
                                      issapicrule, role='Device']:
   [ State_11111121211111111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  -->
   [ ]

  /*
  rule (modulo AC) p_0_11111121211111111[color=#708040, process='0',
                                         issapicrule, role='Device']:
     [ State_11111121211111111( lock, s, sk, x, y, status ) ] --> [ ]
  */

rule (modulo E) ifstatusright_0_11111121211112[color=#708040,
                                               process='if status.2='right'', issapicrule, role='Device']:
   [ State_11111121211112( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Pred_Eq( status.2, 'right' ) ]->
   [ State_111111212111121( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) ifstatusright_0_11111121211112[color=#708040,
                                                  process='if status.2='right'', issapicrule, role='Device']:
     [ State_11111121211112( lock, s, sk, x, y, status ) ]
    --[ Pred_Eq( status, 'right' ) ]->
     [ State_111111212111121( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) ifstatusright_1_11111121211112[color=#708040,
                                               process='if status.2='right'', issapicrule, role='Device']:
   [ State_11111121211112( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Pred_Not_Eq( status.2, 'right' ) ]->
   [ State_111111212111122( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) ifstatusright_1_11111121211112[color=#708040,
                                                  process='if status.2='right'', issapicrule, role='Device']:
     [ State_11111121211112( lock, s, sk, x, y, status ) ]
    --[ Pred_Not_Eq( status, 'right' ) ]->
     [ State_111111212111122( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) eventAccessy_0_111111212111121[color=#708040,
                                               process='event Access( y.1 );', issapicrule, role='Device']:
   [ State_111111212111121( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Access( y.1 ) ]->
   [ State_1111112121111211( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) eventAccessy_0_111111212111121[color=#708040,
                                                  process='event Access( y.1 );', issapicrule, role='Device']:
     [ State_111111212111121( lock, s, sk, x, y, status ) ]
    --[ Access( y ) ]->
     [ State_1111112121111211( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) outy_0_1111112121111211[color=#708040,
                                        process='out(y.1);', issapicrule, role='Device']:
   [ State_1111112121111211( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  -->
   [
   State_11111121211112111( lock.1, s.1, sk.1, x.1, y.1, status.2 ),
   Out( y.1 )
   ]

  /*
  rule (modulo AC) outy_0_1111112121111211[color=#708040,
                                           process='out(y.1);', issapicrule, role='Device']:
     [ State_1111112121111211( lock, s, sk, x, y, status ) ]
    -->
     [ State_11111121211112111( lock, s, sk, x, y, status ), Out( y ) ]
  */

rule (modulo E) unlocks_0_11111121211112111[color=#708040,
                                            process='unlock s.1;', issapicrule, role='Device']:
   [ State_11111121211112111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Unlock_1( '1', lock.1, s.1 ), Unlock( '1', lock.1, s.1 ) ]->
   [ State_111111212111121111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) unlocks_0_11111121211112111[color=#708040,
                                               process='unlock s.1;', issapicrule, role='Device']:
     [ State_11111121211112111( lock, s, sk, x, y, status ) ]
    --[ Unlock_1( '1', lock, s ), Unlock( '1', lock, s ) ]->
     [ State_111111212111121111( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) p_0_111111212111121111[color=#708040, process='0',
                                       issapicrule, role='Device']:
   [ State_111111212111121111( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  -->
   [ ]

  /*
  rule (modulo AC) p_0_111111212111121111[color=#708040, process='0',
                                          issapicrule, role='Device']:
     [ State_111111212111121111( lock, s, sk, x, y, status ) ] --> [ ]
  */

rule (modulo E) unlocks_0_111111212111122[color=#708040,
                                          process='unlock s.1;', issapicrule, role='Device']:
   [ State_111111212111122( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  --[ Unlock_1( '1', lock.1, s.1 ), Unlock( '1', lock.1, s.1 ) ]->
   [ State_1111112121111221( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]

  /*
  rule (modulo AC) unlocks_0_111111212111122[color=#708040,
                                             process='unlock s.1;', issapicrule, role='Device']:
     [ State_111111212111122( lock, s, sk, x, y, status ) ]
    --[ Unlock_1( '1', lock, s ), Unlock( '1', lock, s ) ]->
     [ State_1111112121111221( lock, s, sk, x, y, status ) ]
  */

rule (modulo E) p_0_1111112121111221[color=#708040, process='0',
                                     issapicrule, role='Device']:
   [ State_1111112121111221( lock.1, s.1, sk.1, x.1, y.1, status.2 ) ]
  -->
   [ ]

  /*
  rule (modulo AC) p_0_1111112121111221[color=#708040, process='0',
                                        issapicrule, role='Device']:
     [ State_1111112121111221( lock, s, sk, x, y, status ) ] --> [ ]
  */

rule (modulo E) p_0_1111112121112[color=#708040, process='0',
                                  issapicrule, role='Device']:
   [ State_1111112121112( lock.1, s.1, sk.1, x.1, y.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111112121112[color=#708040, process='0',
                                     issapicrule, role='Device']:
     [ State_1111112121112( lock, s, sk, x, y ) ] --> [ ]
  */

rule (modulo E) p_0_111112[color=#ffffff, process='0', issapicrule,
                           role='Process']:
   [ State_111112( s.1, sk.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111112[color=#ffffff, process='0', issapicrule,
                              role='Process']:
     [ State_111112( s, sk ) ] --> [ ]
  */

rule (modulo E) p_0_11112[color=#ffffff, process='!', issapicrule,
                          role='Process']:
   [ State_11112( s.1, sk.1 ) ] --> [ !Semistate_111121( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_0_11112[color=#ffffff, process='!', issapicrule,
                             role='Process']:
     [ State_11112( s, sk ) ] --> [ !Semistate_111121( s, sk ) ]
  */

rule (modulo E) p_1_11112[color=#ffffff, process='!', issapicrule,
                          role='Process']:
   [ !Semistate_111121( s.1, sk.1 ) ] --> [ State_111121( s.1, sk.1 ) ]

  /*
  rule (modulo AC) p_1_11112[color=#ffffff, process='!', issapicrule,
                             role='Process']:
     [ !Semistate_111121( s, sk ) ] --> [ State_111121( s, sk ) ]
  */

rule (modulo E) User_0_111121[color=#ffffff, process='User()',
                              issapicrule, role='Process']:
   [ State_111121( s.1, sk.1 ) ]
  -->
   [ State_1111211( s.1, sk.1 ), State_1111212( s.1, sk.1 ) ]

  /*
  rule (modulo AC) User_0_111121[color=#ffffff, process='User()',
                                 issapicrule, role='Process']:
     [ State_111121( s, sk ) ]
    -->
     [ State_1111211( s, sk ), State_1111212( s, sk ) ]
  */

rule (modulo E) newlm_0_1111211[color=#80406c, process='new lm.1;',
                                issapicrule, role='User']:
   [ State_1111211( s.1, sk.1 ), Fr( lm.1 ) ]
  -->
   [ State_11112111( lm.1, s.1, sk.1 ) ]

  /*
  rule (modulo AC) newlm_0_1111211[color=#80406c, process='new lm.1;',
                                   issapicrule, role='User']:
     [ State_1111211( s, sk ), Fr( lm ) ] --> [ State_11112111( lm, s, sk ) ]
  */

rule (modulo E) newrm_0_11112111[color=#80406c, process='new rm.1;',
                                 issapicrule, role='User']:
   [ State_11112111( lm.1, s.1, sk.1 ), Fr( rm.1 ) ]
  -->
   [ State_111121111( lm.1, rm.1, s.1, sk.1 ) ]

  /*
  rule (modulo AC) newrm_0_11112111[color=#80406c, process='new rm.1;',
                                    issapicrule, role='User']:
     [ State_11112111( lm, s, sk ), Fr( rm ) ]
    -->
     [ State_111121111( lm, rm, s, sk ) ]
  */

rule (modulo E) eventExclusivelmrm_0_111121111[color=#80406c,
                                               process='event Exclusive( lm.1, rm.1 );', issapicrule,
                                               role='User']:
   [ State_111121111( lm.1, rm.1, s.1, sk.1 ) ]
  --[ Exclusive( lm.1, rm.1 ) ]->
   [ State_1111211111( lm.1, rm.1, s.1, sk.1 ) ]

  /*
  rule (modulo AC) eventExclusivelmrm_0_111121111[color=#80406c,
                                                  process='event Exclusive( lm.1, rm.1 );', issapicrule,
                                                  role='User']:
     [ State_111121111( lm, rm, s, sk ) ]
    --[ Exclusive( lm, rm ) ]->
     [ State_1111211111( lm, rm, s, sk ) ]
  */

rule (modulo E) outaenclmrmpksk_0_1111211111[color=#80406c,
                                             process='out(aenc(<lm.1, rm.1>, pk(sk.1)));', issapicrule,
                                             role='User']:
   [ State_1111211111( lm.1, rm.1, s.1, sk.1 ) ]
  -->
   [
   State_11112111111( lm.1, rm.1, s.1, sk.1 ),
   Out( aenc(<lm.1, rm.1>, pk(sk.1)) )
   ]

  /*
  rule (modulo AC) outaenclmrmpksk_0_1111211111[color=#80406c,
                                                process='out(aenc(<lm.1, rm.1>, pk(sk.1)));', issapicrule,
                                                role='User']:
     [ State_1111211111( lm, rm, s, sk ) ]
    -->
     [ State_11112111111( lm, rm, s, sk ), Out( aenc(<lm, rm>, pk(sk)) ) ]
  */

rule (modulo E) p_0_11112111111[color=#80406c, process='0', issapicrule,
                                role='User']:
   [ State_11112111111( lm.1, rm.1, s.1, sk.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11112111111[color=#80406c, process='0', issapicrule,
                                   role='User']:
     [ State_11112111111( lm, rm, s, sk ) ] --> [ ]
  */

rule (modulo E) p_0_1111212[color=#ffffff, process='0', issapicrule,
                            role='Process']:
   [ State_1111212( s.1, sk.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111212[color=#ffffff, process='0', issapicrule,
                               role='Process']:
     [ State_1111212( s, sk ) ] --> [ ]
  */

restriction set_in:
  "∀ x y #t3.
    (IsIn( x, y ) @ #t3) ⇒
    (∃ #t2.
      ((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ∧
      (∀ #t1 yp.
        (Insert( x, yp ) @ #t1) ⇒ (((#t1 < #t2) ∨ (#t1 = #t2)) ∨ (#t3 < #t1))))"

restriction set_notin:
  "∀ x #t3.
    (IsNotSet( x ) @ #t3) ⇒ (∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ (#t3 < #t1))"
  // safety formula

restriction predicate_eq:
  "∀ #i a b. (Pred_Eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction predicate_not_eq:
  "∀ #i a b. (Pred_Not_Eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction locking_0:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_0( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_1:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_1( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

/*
WARNING: the following wellformedness checks failed!

Wellformedness-error in Process
  There is an unlock that cannot be matched with a lock.
*/

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.4
Git revision: b954f6565e030d682d7951db74b7033939ef638b (with uncommited changes), branch: develop
Compiled at: 2025-06-06 08:30:52.256236371 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/sapic/fast/statVerifLeftRight/stateverif_left_right.spthy

  output:          examples/sapic/fast/statVerifLeftRight/stateverif_left_right.spthy.tmp
  processing time: 14.40s
  
  WARNING: 1 wellformedness check failed!
           The analysis results might be wrong!
  
  source (all-traces): verified (171 steps)
  reachability_left (exists-trace): verified (14 steps)
  reachability_right (exists-trace): verified (14 steps)
  secrecy (all-traces): verified (198 steps)

==============================================================================
*/
