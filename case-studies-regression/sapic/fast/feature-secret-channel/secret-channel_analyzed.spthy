theory ChannelsTestOne begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, pk/1, sign/2, snd/1, true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true



heuristic: p





lemma secret:
  all-traces "∀ x #i. (Secret( x ) @ #i) ⇒ (¬(∃ #j. K( x ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (Secret( x ) @ #i) ∧ ∃ #j. (K( x ) @ #j)"
*/
simplify
solve( State_11111111( c1, c2, x, skP2 ) ▶₀ #i )
  case p_0_1111111
  by solve( !KU( ~n.2 ) @ #vk )
qed

lemma auth:
  all-traces
  "∀ x #i. (Accept( x ) @ #i) ⇒ (∃ #j. (#j < #i) ∧ (Received( x ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (Accept( x ) @ #i) ∧ ∀ #j. (Received( x ) @ #j) ⇒ ¬(#j < #i)"
*/
simplify
solve( State_111111121( c1, c2, x, skP2 ) ▶₀ #i )
  case insigntestskP_0_11111112
  solve( !KU( sign('test', ~n.2) ) @ #vk )
    case c_sign
    by solve( !KU( ~n.2 ) @ #vk.2 )
  next
    case outsigntestx_0_11111211
    by contradiction /* from formulas */
  qed
qed

lemma auth2:
  all-traces
  "∀ x #i. (Accept2( x ) @ #i) ⇒ (∃ #j. (#j < #i) ∧ (Received2( x ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (Accept2( x ) @ #i) ∧ ∀ #j. (Received2( x ) @ #j) ⇒ ¬(#j < #i)"
*/
simplify
solve( State_11111121( c1, c2, skP1, x ) ▶₀ #i )
  case insigntestskP_0_1111112
  solve( !KU( sign('test', ~n.3) ) @ #vk )
    case c_sign
    by solve( !KU( ~n.3 ) @ #vk.2 )
  next
    case outsigntestx_0_1111211
    by contradiction /* from formulas */
  qed
qed

lemma accept:
  exists-trace "∃ x #i. Accept( x ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ x #i. (Accept( x ) @ #i)"
*/
simplify
solve( State_111111121( c1, c2, x, skP2 ) ▶₀ #i )
  case insigntestskP_0_11111112
  solve( !KU( sign('test', ~n.2) ) @ #vk )
    case outsigntestx_0_11111211
    SOLVED // trace found
  qed
qed

lemma accept2:
  exists-trace "∃ x #i. Accept2( x ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ x #i. (Accept2( x ) @ #i)"
*/
simplify
solve( State_11111121( c1, c2, skP1, x ) ▶₀ #i )
  case insigntestskP_0_1111112
  solve( !KU( sign('test', ~n.3) ) @ #vk )
    case outsigntestx_0_1111211
    solve( Ack( ~n, ~n.2 ) ▶₁ #vr.14 )
      case incx_0_111112
      SOLVED // trace found
    qed
  qed
qed















rule (modulo E) Init[color=#ffffff, process="new skP1.1;", issapicrule,
                     role='Process']:
   [ ] --[ Init( ) ]-> [ State_( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) newskP_0_[color=#ffffff, process="new skP1.1;",
                          issapicrule, role='Process']:
   [ State_( ), Fr( skP1.1 ) ] --> [ State_1( skP1.1 ) ]

  /*
  rule (modulo AC) newskP_0_[color=#ffffff, process="new skP1.1;",
                             issapicrule, role='Process']:
     [ State_( ), Fr( skP1 ) ] --> [ State_1( skP1 ) ]
  */

rule (modulo E) newskP_0_1[color=#ffffff, process="new skP2.1;",
                           issapicrule, role='Process']:
   [ State_1( skP1.1 ), Fr( skP2.1 ) ] --> [ State_11( skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) newskP_0_1[color=#ffffff, process="new skP2.1;",
                              issapicrule, role='Process']:
     [ State_1( skP1 ), Fr( skP2 ) ] --> [ State_11( skP1, skP2 ) ]
  */

rule (modulo E) newc_0_11[color=#ffffff, process="new c1.1;",
                          issapicrule, role='Process']:
   [ State_11( skP1.1, skP2.1 ), Fr( c1.1 ) ]
  -->
   [ State_111( c1.1, skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) newc_0_11[color=#ffffff, process="new c1.1;",
                             issapicrule, role='Process']:
     [ State_11( skP1, skP2 ), Fr( c1 ) ] --> [ State_111( c1, skP1, skP2 ) ]
  */

rule (modulo E) newc_0_111[color=#ffffff, process="new c2.1;",
                           issapicrule, role='Process']:
   [ State_111( c1.1, skP1.1, skP2.1 ), Fr( c2.1 ) ]
  -->
   [ State_1111( c1.1, c2.1, skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) newc_0_111[color=#ffffff, process="new c2.1;",
                              issapicrule, role='Process']:
     [ State_111( c1, skP1, skP2 ), Fr( c2 ) ]
    -->
     [ State_1111( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) p_0_1111[color=#ffffff, process="|", issapicrule,
                         role='Process']:
   [ State_1111( c1.1, c2.1, skP1.1, skP2.1 ) ]
  -->
   [
   State_11111( c1.1, c2.1, skP1.1, skP2.1 ),
   State_11112( c1.1, c2.1, skP1.1, skP2.1 )
   ]

  /*
  rule (modulo AC) p_0_1111[color=#ffffff, process="|", issapicrule,
                            role='Process']:
     [ State_1111( c1, c2, skP1, skP2 ) ]
    -->
     [ State_11111( c1, c2, skP1, skP2 ), State_11112( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) p_0_11111[color=#ffffff, process="|", issapicrule,
                          role='Process']:
   [ State_11111( c1.1, c2.1, skP1.1, skP2.1 ) ]
  -->
   [
   State_111111( c1.1, c2.1, skP1.1, skP2.1 ),
   State_111112( c1.1, c2.1, skP1.1, skP2.1 )
   ]

  /*
  rule (modulo AC) p_0_11111[color=#ffffff, process="|", issapicrule,
                             role='Process']:
     [ State_11111( c1, c2, skP1, skP2 ) ]
    -->
     [ State_111111( c1, c2, skP1, skP2 ), State_111112( c1, c2, skP1, skP2 )
     ]
  */

rule (modulo E) p_0_111111[color=#ffffff, process="|", issapicrule,
                           role='Process']:
   [ State_111111( c1.1, c2.1, skP1.1, skP2.1 ) ]
  -->
   [
   State_1111111( c1.1, c2.1, skP1.1, skP2.1 ),
   State_1111112( c1.1, c2.1, skP1.1, skP2.1 )
   ]

  /*
  rule (modulo AC) p_0_111111[color=#ffffff, process="|", issapicrule,
                              role='Process']:
     [ State_111111( c1, c2, skP1, skP2 ) ]
    -->
     [
     State_1111111( c1, c2, skP1, skP2 ), State_1111112( c1, c2, skP1, skP2 )
     ]
  */

rule (modulo E) p_0_1111111[color=#ffffff, process="|", issapicrule,
                            role='Process']:
   [ State_1111111( c1.1, c2.1, skP1.1, skP2.1 ) ]
  -->
   [
   State_11111111( c1.1, c2.1, skP1.1, skP2.1 ),
   State_11111112( c1.1, c2.1, skP1.1, skP2.1 )
   ]

  /*
  rule (modulo AC) p_0_1111111[color=#ffffff, process="|", issapicrule,
                               role='Process']:
     [ State_1111111( c1, c2, skP1, skP2 ) ]
    -->
     [
     State_11111111( c1, c2, skP1, skP2 ),
     State_11111112( c1, c2, skP1, skP2 )
     ]
  */

rule (modulo E) eventSecretskP_0_11111111[color=#ffffff,
                                          process="event Secret( skP1.1 );", issapicrule, role='Process']:
   [ State_11111111( c1.1, c2.1, skP1.1, skP2.1 ) ]
  --[ Secret( skP1.1 ) ]->
   [ State_111111111( c1.1, c2.1, skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) eventSecretskP_0_11111111[color=#ffffff,
                                             process="event Secret( skP1.1 );", issapicrule, role='Process']:
     [ State_11111111( c1, c2, skP1, skP2 ) ]
    --[ Secret( skP1 ) ]->
     [ State_111111111( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) outcskP_0_111111111[color=#ffffff,
                                    process="out(c1.1,skP1.1);", issapicrule, role='Process']:
   [ State_111111111( c1.1, c2.1, skP1.1, skP2.1 ) ]
  -->
   [
   Message( c1.1, skP1.1 ),
   Semistate_1111111111( c1.1, c2.1, skP1.1, skP2.1 )
   ]

  /*
  rule (modulo AC) outcskP_0_111111111[color=#ffffff,
                                       process="out(c1.1,skP1.1);", issapicrule, role='Process']:
     [ State_111111111( c1, c2, skP1, skP2 ) ]
    -->
     [ Message( c1, skP1 ), Semistate_1111111111( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) outcskP_1_111111111[color=#ffffff,
                                    process="out(c1.1,skP1.1);", issapicrule, role='Process']:
   [ Semistate_1111111111( c1.1, c2.1, skP1.1, skP2.1 ), Ack( c1.1, skP1.1 )
   ]
  -->
   [ State_1111111111( c1.1, c2.1, skP1.1, skP2.1 ) ]

  // loop breaker: [1]
  /*
  rule (modulo AC) outcskP_1_111111111[color=#ffffff,
                                       process="out(c1.1,skP1.1);", issapicrule, role='Process']:
     [ Semistate_1111111111( c1, c2, skP1, skP2 ), Ack( c1, skP1 ) ]
    -->
     [ State_1111111111( c1, c2, skP1, skP2 ) ]
    // loop breaker: [1]
  */

rule (modulo E) outcskP_0_1111111111[color=#ffffff,
                                     process="out(c2.1,skP2.1);", issapicrule, role='Process']:
   [ State_1111111111( c1.1, c2.1, skP1.1, skP2.1 ) ]
  -->
   [
   Message( c2.1, skP2.1 ),
   Semistate_11111111111( c1.1, c2.1, skP1.1, skP2.1 )
   ]

  /*
  rule (modulo AC) outcskP_0_1111111111[color=#ffffff,
                                        process="out(c2.1,skP2.1);", issapicrule, role='Process']:
     [ State_1111111111( c1, c2, skP1, skP2 ) ]
    -->
     [ Message( c2, skP2 ), Semistate_11111111111( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) outcskP_1_1111111111[color=#ffffff,
                                     process="out(c2.1,skP2.1);", issapicrule, role='Process']:
   [
   Semistate_11111111111( c1.1, c2.1, skP1.1, skP2.1 ), Ack( c2.1, skP2.1 )
   ]
  -->
   [ State_11111111111( c1.1, c2.1, skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) outcskP_1_1111111111[color=#ffffff,
                                        process="out(c2.1,skP2.1);", issapicrule, role='Process']:
     [ Semistate_11111111111( c1, c2, skP1, skP2 ), Ack( c2, skP2 ) ]
    -->
     [ State_11111111111( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) p_0_11111111111[color=#ffffff, process="0", issapicrule,
                                role='Process']:
   [ State_11111111111( c1.1, c2.1, skP1.1, skP2.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11111111111[color=#ffffff, process="0", issapicrule,
                                   role='Process']:
     [ State_11111111111( c1, c2, skP1, skP2 ) ] --> [ ]
  */

rule (modulo E) insigntestskP_0_11111112[color=#ffffff,
                                         process="in(sign('test', =skP1.1));", issapicrule, role='Process']:
   [
   State_11111112( c1.1, c2.1, skP1.1, skP2.1 ), In( sign('test', skP1.1) )
   ]
  -->
   [ State_111111121( c1.1, c2.1, skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) insigntestskP_0_11111112[color=#ffffff,
                                            process="in(sign('test', =skP1.1));", issapicrule,
                                            role='Process']:
     [ State_11111112( c1, c2, skP1, skP2 ), In( sign('test', skP1) ) ]
    -->
     [ State_111111121( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) eventAcceptskP_0_111111121[color=#ffffff,
                                           process="event Accept( skP1.1 );", issapicrule, role='Process']:
   [ State_111111121( c1.1, c2.1, skP1.1, skP2.1 ) ]
  --[ Accept( skP1.1 ) ]->
   [ State_1111111211( c1.1, c2.1, skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) eventAcceptskP_0_111111121[color=#ffffff,
                                              process="event Accept( skP1.1 );", issapicrule, role='Process']:
     [ State_111111121( c1, c2, skP1, skP2 ) ]
    --[ Accept( skP1 ) ]->
     [ State_1111111211( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) p_0_1111111211[color=#ffffff, process="0", issapicrule,
                               role='Process']:
   [ State_1111111211( c1.1, c2.1, skP1.1, skP2.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111111211[color=#ffffff, process="0", issapicrule,
                                  role='Process']:
     [ State_1111111211( c1, c2, skP1, skP2 ) ] --> [ ]
  */

rule (modulo E) insigntestskP_0_1111112[color=#ffffff,
                                        process="in(sign('test', =skP2.1));", issapicrule, role='Process']:
   [ State_1111112( c1.1, c2.1, skP1.1, skP2.1 ), In( sign('test', skP2.1) )
   ]
  -->
   [ State_11111121( c1.1, c2.1, skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) insigntestskP_0_1111112[color=#ffffff,
                                           process="in(sign('test', =skP2.1));", issapicrule, role='Process']:
     [ State_1111112( c1, c2, skP1, skP2 ), In( sign('test', skP2) ) ]
    -->
     [ State_11111121( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) eventAcceptskP_0_11111121[color=#ffffff,
                                          process="event Accept2( skP2.1 );", issapicrule, role='Process']:
   [ State_11111121( c1.1, c2.1, skP1.1, skP2.1 ) ]
  --[ Accept2( skP2.1 ) ]->
   [ State_111111211( c1.1, c2.1, skP1.1, skP2.1 ) ]

  /*
  rule (modulo AC) eventAcceptskP_0_11111121[color=#ffffff,
                                             process="event Accept2( skP2.1 );", issapicrule, role='Process']:
     [ State_11111121( c1, c2, skP1, skP2 ) ]
    --[ Accept2( skP2 ) ]->
     [ State_111111211( c1, c2, skP1, skP2 ) ]
  */

rule (modulo E) p_0_111111211[color=#ffffff, process="0", issapicrule,
                              role='Process']:
   [ State_111111211( c1.1, c2.1, skP1.1, skP2.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111111211[color=#ffffff, process="0", issapicrule,
                                 role='Process']:
     [ State_111111211( c1, c2, skP1, skP2 ) ] --> [ ]
  */

rule (modulo E) incx_0_111112[color=#ffffff, process="in(c1.1,x.1);",
                              issapicrule, role='Process']:
   [ State_111112( c1.1, c2.1, skP1.1, skP2.1 ), Message( c1.1, x.2 ) ]
  -->
   [ Let_1111121( x.2, c1.1, c2.1, skP1.1, skP2.1 ), Ack( c1.1, x.2 ) ]

  /*
  rule (modulo AC) incx_0_111112[color=#ffffff, process="in(c1.1,x.1);",
                                 issapicrule, role='Process']:
     [ State_111112( c1, c2, skP1, skP2 ), Message( c1, x ) ]
    -->
     [ Let_1111121( x, c1, c2, skP1, skP2 ), Ack( c1, x ) ]
  */

rule (modulo E) incx_1_111112[color=#ffffff, process="in(c1.1,x.1);",
                              issapicrule, role='Process']:
   [ Let_1111121( x.1, c1.1, c2.1, skP1.1, skP2.1 ) ]
  -->
   [ State_1111121( c1.1, c2.1, skP1.1, skP2.1, x.1 ) ]

  /*
  rule (modulo AC) incx_1_111112[color=#ffffff, process="in(c1.1,x.1);",
                                 issapicrule, role='Process']:
     [ Let_1111121( x, c1, c2, skP1, skP2 ) ]
    -->
     [ State_1111121( c1, c2, skP1, skP2, x ) ]
  */

rule (modulo E) eventReceivedx_0_1111121[color=#ffffff,
                                         process="event Received( x.1 );", issapicrule, role='Process']:
   [ State_1111121( c1.1, c2.1, skP1.1, skP2.1, x.1 ) ]
  --[ Received( x.1 ) ]->
   [ State_11111211( c1.1, c2.1, skP1.1, skP2.1, x.1 ) ]

  /*
  rule (modulo AC) eventReceivedx_0_1111121[color=#ffffff,
                                            process="event Received( x.1 );", issapicrule, role='Process']:
     [ State_1111121( c1, c2, skP1, skP2, x ) ]
    --[ Received( x ) ]->
     [ State_11111211( c1, c2, skP1, skP2, x ) ]
  */

rule (modulo E) outsigntestx_0_11111211[color=#ffffff,
                                        process="out(sign('test', x.1));", issapicrule, role='Process']:
   [ State_11111211( c1.1, c2.1, skP1.1, skP2.1, x.1 ) ]
  -->
   [
   State_111112111( c1.1, c2.1, skP1.1, skP2.1, x.1 ),
   Out( sign('test', x.1) )
   ]

  /*
  rule (modulo AC) outsigntestx_0_11111211[color=#ffffff,
                                           process="out(sign('test', x.1));", issapicrule, role='Process']:
     [ State_11111211( c1, c2, skP1, skP2, x ) ]
    -->
     [ State_111112111( c1, c2, skP1, skP2, x ), Out( sign('test', x) ) ]
  */

rule (modulo E) p_0_111112111[color=#ffffff, process="0", issapicrule,
                              role='Process']:
   [ State_111112111( c1.1, c2.1, skP1.1, skP2.1, x.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111112111[color=#ffffff, process="0", issapicrule,
                                 role='Process']:
     [ State_111112111( c1, c2, skP1, skP2, x ) ] --> [ ]
  */

rule (modulo E) incx_0_11112[color=#ffffff, process="in(c2.1,x.2);",
                             issapicrule, role='Process']:
   [ State_11112( c1.1, c2.1, skP1.1, skP2.1 ), Message( c2.1, x.2 ) ]
  -->
   [ Let_111121( x.2, c1.1, c2.1, skP1.1, skP2.1 ), Ack( c2.1, x.2 ) ]

  /*
  rule (modulo AC) incx_0_11112[color=#ffffff, process="in(c2.1,x.2);",
                                issapicrule, role='Process']:
     [ State_11112( c1, c2, skP1, skP2 ), Message( c2, x ) ]
    -->
     [ Let_111121( x, c1, c2, skP1, skP2 ), Ack( c2, x ) ]
  */

rule (modulo E) incx_1_11112[color=#ffffff, process="in(c2.1,x.2);",
                             issapicrule, role='Process']:
   [ Let_111121( x.2, c1.1, c2.1, skP1.1, skP2.1 ) ]
  -->
   [ State_111121( c1.1, c2.1, skP1.1, skP2.1, x.2 ) ]

  /*
  rule (modulo AC) incx_1_11112[color=#ffffff, process="in(c2.1,x.2);",
                                issapicrule, role='Process']:
     [ Let_111121( x, c1, c2, skP1, skP2 ) ]
    -->
     [ State_111121( c1, c2, skP1, skP2, x ) ]
  */

rule (modulo E) eventReceivedx_0_111121[color=#ffffff,
                                        process="event Received2( x.2 );", issapicrule, role='Process']:
   [ State_111121( c1.1, c2.1, skP1.1, skP2.1, x.2 ) ]
  --[ Received2( x.2 ) ]->
   [ State_1111211( c1.1, c2.1, skP1.1, skP2.1, x.2 ) ]

  /*
  rule (modulo AC) eventReceivedx_0_111121[color=#ffffff,
                                           process="event Received2( x.2 );", issapicrule, role='Process']:
     [ State_111121( c1, c2, skP1, skP2, x ) ]
    --[ Received2( x ) ]->
     [ State_1111211( c1, c2, skP1, skP2, x ) ]
  */

rule (modulo E) outsigntestx_0_1111211[color=#ffffff,
                                       process="out(sign('test', x.2));", issapicrule, role='Process']:
   [ State_1111211( c1.1, c2.1, skP1.1, skP2.1, x.2 ) ]
  -->
   [
   State_11112111( c1.1, c2.1, skP1.1, skP2.1, x.2 ),
   Out( sign('test', x.2) )
   ]

  /*
  rule (modulo AC) outsigntestx_0_1111211[color=#ffffff,
                                          process="out(sign('test', x.2));", issapicrule, role='Process']:
     [ State_1111211( c1, c2, skP1, skP2, x ) ]
    -->
     [ State_11112111( c1, c2, skP1, skP2, x ), Out( sign('test', x) ) ]
  */

rule (modulo E) p_0_11112111[color=#ffffff, process="0", issapicrule,
                             role='Process']:
   [ State_11112111( c1.1, c2.1, skP1.1, skP2.1, x.2 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11112111[color=#ffffff, process="0", issapicrule,
                                role='Process']:
     [ State_11112111( c1, c2, skP1, skP2, x ) ] --> [ ]
  */

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.4
Git revision: a288673cab40b1e997ba23b077ef491d39c2bef6 (with uncommited changes), branch: fix-issue713
Compiled at: 2025-06-18 14:31:09.981542 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/sapic/fast/feature-secret-channel/secret-channel.spthy

  output:          examples/sapic/fast/feature-secret-channel/secret-channel.spthy.tmp
  processing time: 1.12s
  
  secret (all-traces): verified (3 steps)
  auth (all-traces): verified (5 steps)
  auth2 (all-traces): verified (5 steps)
  accept (exists-trace): verified (4 steps)
  accept2 (exists-trace): verified (5 steps)

==============================================================================
*/
